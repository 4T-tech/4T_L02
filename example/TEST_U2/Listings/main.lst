C51 COMPILER V9.60.7.0   MAIN                                                              01/21/2025 15:14:52 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c COMPACT OPTIMIZE(8,SPEED) BROWSE INCDIR(..\TEST_U2) DEBUG OBJECTE
                    -XTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "stc12.h"
   2          #include <intrins.h>
   3          #include <string.h>
   4          #include "ds18b20.h"
   5          #include "at24c02.h"
   6          #include "ds1302.h"
   7          #include "pcf8591.h"
   8          
   9          /*
  10          两个数码管    √
  11          开机次数      √
  12          RTC           √
  13          8951          √
  14          矩阵键盘
  15          两个中断按键
  16          串口报18b20   √
  17          */
  18          
  19          
  20          #define uint8_t  unsigned char
  21          #define uint16_t unsigned int
  22            
  23          sbit S1 = P1^0;
  24          sbit S2 = P1^1;
  25          sbit S3 = P1^2;
  26          sbit S4 = P1^3;
  27          
  28          uint8_t printf_data[33] = "$TEAWJX$000000000000000000000000$"; 
  29          uint8_t rom_data[8];
  30          
  31          uint8_t wake_times;
  32          
  33          uint8_t seg_number[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e,0xbf
             -};     //0～9、A～F的共阳极显示码
  34          uint8_t seg_com[9] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0xff}; //从左到右
  35          uint8_t seg_data[8] = {0};
  36          
  37          uint8_t adc_data;
  38          
  39          uint8_t key_status = 5;
  40          uint8_t key_status_old;
  41          
  42          void uart_init();
  43          void uart_send_data(uint8_t *tdata,uint8_t length);
  44          void rom_code_c();
  45          void delay_ms(uint16_t times);
  46          void seg_dispaly(uint8_t *tdata,uint8_t com_control);
  47          void seg_serial();
  48          uint8_t at24c02_init();
  49          void display_waketimes(uint8_t wake_times);
  50          void display_ds1302(void);
  51          void pcf8591_dac(uint8_t dac);
  52          void pcf8591_adc(uint8_t channel);
  53          void keyboart_check(void);
C51 COMPILER V9.60.7.0   MAIN                                                              01/21/2025 15:14:52 PAGE 2   

  54          void task(uint8_t i);
  55            
  56          
  57          void main()
  58          {
  59   1        uint8_t i;
  60   1        
  61   1        uart_init();
  62   1        
  63   1        /* get wake times */
  64   1        wake_times = at24c02_init();
  65   1        
  66   1        /* get ds18b20 romdata*/
  67   1        ReadRomCode(rom_data);
  68   1        rom_code_c();
  69   1        uart_send_data(printf_data,33);
  70   1        
  71   1        /* serial seg display*/
  72   1        seg_serial();
  73   1      
  74   1        /* rtc */
  75   1        InitRTCStruct();
  76   1        GetRTCStruct()->Set();
  77   1        
  78   1        /* 8591 */
  79   1        InitPCF8591();
  80   1        
  81   1        while(1) 
  82   1        {
  83   2          keyboart_check();
  84   2          task(i++);
  85   2          
  86   2          
  87   2          
  88   2          //pcf8591_adc(1);
  89   2          
  90   2          //display_ds1302();
  91   2          //显示开机次数
  92   2          //display_waketimes(wake_times);
  93   2          
  94   2        }
  95   1      }
  96          
  97          void uart_init() 
  98          { 
  99   1        PCON &= 0x7F;   //波特率不倍速
 100   1        SCON = 0x50;    //8位数据,可变波特率
 101   1        TMOD &= 0x0F;   //设置定时器模式
 102   1        TMOD |= 0x20;   //设置定时器模式
 103   1        TL1 = 0xFD;     //设置定时初始值
 104   1        TH1 = 0xFD;     //设置定时重载值
 105   1        ET1 = 0;      //禁止定时器中断
 106   1        TR1 = 1;      //定时器1开始计时
 107   1      }
 108          
 109          void uart_send_data(uint8_t *tdata,uint8_t length)
 110          {
 111   1        uint8_t i;
 112   1        for (i=0;i<length;i++)
 113   1        {
 114   2          SBUF=*(tdata+i);      // 发送第i个数据
 115   2          while(TI==0);     // 查询等待发送是否完成
C51 COMPILER V9.60.7.0   MAIN                                                              01/21/2025 15:14:52 PAGE 3   

 116   2          TI=0;       // 发送完成，TI由软件清0
 117   2        }
 118   1      }
 119          
 120          void rom_code_c()
 121          {
 122   1        unsigned char index = 0;
 123   1        for(index=0; index<8; index++)
 124   1        {
 125   2          printf_data[8 + 2*index + 0] = ((rom_data[index] >> 4) > 9) ? ((rom_data[index] >> 4) + 55) : ((rom_data
             -[index] >> 4) + 48);
 126   2          printf_data[8 + 2*index + 1] = ((rom_data[index] & 15) > 9) ? ((rom_data[index] & 15) + 55) : ((rom_data
             -[index] & 15) + 48);
 127   2        } 
 128   1      }
 129          
 130          void delay_ms(uint16_t times) //@11.0592MHz
 131          {
 132   1        uint8_t i, j;
 133   1        uint16_t k;
 134   1        for(k=0;k<times;k++)
 135   1        {
 136   2          _nop_();
 137   2          i = 11;
 138   2          j = 190;
 139   2          do
 140   2          {
 141   3            while (--j);
 142   3          } while (--i);
 143   2        }
 144   1      }
 145          /*
 146          tdata  seg_data 
 147          com_control   0x1111_1111  all on
 148                        0x0000_1111  half on
 149          eg.
 150              output  1_95_533
 151              input   tdata[8] = {1,x,9,5,x,5,3,3}
 152                      com_control   = 0x10110111;
 153          */
 154          void seg_dispaly(uint8_t *tdata,uint8_t com_control)
 155          {
 156   1        uint8_t i; 
 157   1        
 158   1        for(i=0;i<8;i++) //遍历com
 159   1        {
 160   2          P0=0xff;      //关显示
 161   2          P20 = 0;      //写com
 162   2          if((com_control>>(7-i)& 0x01) == 1)
 163   2          {
 164   3            P0=~seg_com[i]; //位选码送位控制口P0口 
 165   3          }
 166   2          else
 167   2          {
 168   3            P0=~seg_com[8];
 169   3          }
 170   2          P20 = 1;
 171   2          P0=seg_number[*(tdata+i)];                  //显示字型码送P1口
 172   2          delay_ms(1);  
 173   2        }
 174   1        
 175   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              01/21/2025 15:14:52 PAGE 4   

 176          
 177          void seg_serial()
 178          {
 179   1        uint8_t i;
 180   1        P23 = 0;
 181   1        SCON=0x00;          //设串行口方式0
 182   1        P23 = 1;
 183   1        for (i=0;i<0x0f;i++)    
 184   1        { 
 185   2          SBUF=seg_number[i];     //送显示数据
 186   2          TI=0;
 187   2          while(!TI);     //等待发送完毕
 188   2          delay_ms(100);
 189   2        }
 190   1        SBUF=seg_number[8];     //送显示数据
 191   1        TI=0;
 192   1        while(!TI);     //等待发送完毕
 193   1        SBUF=seg_number[8];     //送显示数据
 194   1        TI=0;
 195   1        while(!TI);     //等待发送完毕
 196   1      }
 197          
 198          uint8_t at24c02_init()
 199          {
 200   1        /*用数码管显示开机次数，模拟i2c另外文件，不然太浪费空间了*/
 201   1        unsigned char times;
 202   1        times = read_AT24C02(254);
 203   1        delay_ms(100);  
 204   1        if(times < 255 )
 205   1        {
 206   2            times=times+1;
 207   2            write_AT24C02(254,times);
 208   2        }
 209   1        else
 210   1        {
 211   2          times = 1;
 212   2          write_AT24C02(254,times);
 213   2          
 214   2        }
 215   1        return times;
 216   1        
 217   1      }
 218          
 219          void display_waketimes(uint8_t wake_times)
 220          {
 221   1        seg_data[5] = wake_times/100;
 222   1        seg_data[6] = wake_times%100/10;
 223   1        seg_data[7] = wake_times%100%10;
 224   1        if(seg_data[5]>0) seg_dispaly(seg_data,0x07);
 225   1        else if(seg_data[5]==0 && seg_data[6]>0) seg_dispaly(seg_data,0x03);
 226   1        else if(seg_data[5]==0 && seg_data[6]==0) seg_dispaly(seg_data,0x01);
 227   1      }
 228          
 229          void display_ds1302(void)
 230          {
 231   1        GetRTCStruct()->Read();
 232   1        seg_data[0] = GetRTCStruct()->rtc[0];
 233   1        seg_data[1] = GetRTCStruct()->rtc[1];
 234   1        seg_data[2] = 16;
 235   1        seg_data[3] = GetRTCStruct()->rtc[2];
 236   1        seg_data[4] = GetRTCStruct()->rtc[3];
 237   1        seg_data[5] = 16;
C51 COMPILER V9.60.7.0   MAIN                                                              01/21/2025 15:14:52 PAGE 5   

 238   1        seg_data[6] = GetRTCStruct()->rtc[4];
 239   1        seg_data[7] = GetRTCStruct()->rtc[5];
 240   1      
 241   1        seg_dispaly(seg_data,0xff);
 242   1      }
 243          
 244          void pcf8591_dac(uint8_t dac)
 245          {
 246   1        SetDAC(dac);
 247   1        if(seg_data[5]>0) seg_dispaly(seg_data,0x07);
 248   1        else if(seg_data[5]==0 && seg_data[6]>0) seg_dispaly(seg_data,0x03);
 249   1        else if(seg_data[5]==0 && seg_data[6]==0) seg_dispaly(seg_data,0x01);
 250   1        
 251   1        seg_data[5] = dac/100;
 252   1        seg_data[6] = dac%100/10;
 253   1        seg_data[7] = dac%100%10;
 254   1      }
 255            
 256          void pcf8591_adc(uint8_t channel)
 257          {
 258   1        uint8_t i;
 259   1        for(i=0;i<5;i++)
 260   1        {
 261   2          if(seg_data[5]>0) seg_dispaly(seg_data,0x07);
 262   2          else if(seg_data[5]==0 && seg_data[6]>0) seg_dispaly(seg_data,0x03);
 263   2          else if(seg_data[5]==0 && seg_data[6]==0) seg_dispaly(seg_data,0x01);
 264   2        }
 265   1        adc_data = GetADC(channel);
 266   1        seg_data[5] = adc_data/100;
 267   1        seg_data[6] = adc_data%100/10;
 268   1        seg_data[7] = adc_data%100%10;
 269   1      
 270   1      }
 271          void keyboart_check(void)
 272          {
 273   1         if(S1 == 0)
 274   1         {
 275   2           if(key_status_old == 1)
 276   2           {
 277   3             key_status = 1;
 278   3           }
 279   2           else
 280   2           {
 281   3             key_status_old = 1;
 282   3           }
 283   2           
 284   2         }
 285   1         else if(S2 == 0)
 286   1         {
 287   2           if(key_status_old == 2)
 288   2           {
 289   3             key_status = 2;
 290   3           }
 291   2           else
 292   2           {
 293   3             key_status_old = 2;
 294   3           }
 295   2           
 296   2         }
 297   1         
 298   1         else if(S3 == 0)
 299   1         {
C51 COMPILER V9.60.7.0   MAIN                                                              01/21/2025 15:14:52 PAGE 6   

 300   2           if(key_status_old == 3)
 301   2           {
 302   3             key_status = 3;
 303   3           }
 304   2           else
 305   2           {
 306   3             key_status_old = 3;
 307   3           }
 308   2           
 309   2         }
 310   1         else if(S4 == 0)
 311   1         {
 312   2           if(key_status_old == 4)
 313   2           {
 314   3             key_status = 4;
 315   3           }
 316   2           else
 317   2           {
 318   3             key_status_old = 4;
 319   3           }
 320   2         }
 321   1      }
 322          
 323          void task(uint8_t i)
 324          {
 325   1        switch(key_status)
 326   1        {
 327   2          case 5:
 328   2            display_waketimes(wake_times);
 329   2            break;
 330   2          case 2:
 331   2            display_ds1302();
 332   2            break;
 333   2          case 3:
 334   2            pcf8591_dac(i);
 335   2            break;
 336   2          case 1:
 337   2            display_waketimes(wake_times);
 338   2          case 4:
 339   2            pcf8591_adc(1);
 340   2            break;
 341   2        }
 342   1      
 343   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    999    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     79      14
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
